/*
 * (C) Copyright 2014 Kurento (http://kurento.org/)
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the GNU Lesser General Public License
 * (LGPL) version 2.1 which accompanies this distribution, and is available at
 * http://www.gnu.org/licenses/lgpl-2.1.html
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 */

#include <gst/check/gstcheck.h>
#include <gst/gst.h>
#include <glib.h>

/* Set to TRUE for manual comprobation of all stuff generated by this test */
/* Do not enable it to pass checks in jenkins in order preserve resources */
#define HUMAN_CHECK_REQUIRED FALSE

#if HUMAN_CHECK_REQUIRED
G_LOCK_DEFINE (mutex);
static guint id = 0;
#endif

static gboolean
quit_main_loop (gpointer data)
{
  g_main_loop_quit (data);

  return G_SOURCE_REMOVE;
}

static void
bus_msg (GstBus * bus, GstMessage * msg, gpointer pipe)
{
  switch (GST_MESSAGE_TYPE (msg)) {
    case GST_MESSAGE_ERROR:{
      GError *err = NULL;
      gchar *dbg_info = NULL;
      gchar *err_str;

      GST_ERROR ("Error: %" GST_PTR_FORMAT, msg);
      GST_DEBUG_BIN_TO_DOT_FILE_WITH_TS (GST_BIN (pipe),
          GST_DEBUG_GRAPH_SHOW_ALL, "bus_error");
      gst_message_parse_error (msg, &err, &dbg_info);

      err_str = g_strdup_printf ("Error received on bus: %s: %s", err->message,
          dbg_info);
      g_error_free (err);
      g_free (dbg_info);

      fail (err_str);
      g_free (err_str);

      break;
    }
    case GST_MESSAGE_STATE_CHANGED:{
      GST_TRACE ("Event: %" GST_PTR_FORMAT, msg);
      break;
    }
    default:
      break;
  }
}

static void
cb_new_pad (GstElement * element, GstPad * pad, gpointer data)
{
  GstElement *pipeline = GST_ELEMENT (data);
  GstElement *wavenc, *sink;
  GstPadLinkReturn ret;
  GstPad *sinkpad;
  gchar *msg;

  if (gst_pad_get_direction (pad) != GST_PAD_SRC)
    return;

  wavenc = gst_element_factory_make ("wavenc", NULL);

#if HUMAN_CHECK_REQUIRED
  {
    gchar *filename;

    G_LOCK (mutex);
    filename = g_strdup_printf ("file_%u.wv", id++);
    G_UNLOCK (mutex);

    sink = gst_element_factory_make ("filesink", NULL);
    g_object_set (G_OBJECT (sink), "location", filename, NULL);
    g_free (filename);
  }
#else
  {
    sink = gst_element_factory_make ("fakesink", NULL);
  }
#endif

  gst_bin_add_many (GST_BIN (pipeline), wavenc, sink, NULL);
  sinkpad = gst_element_get_static_pad (wavenc, "sink");

  if ((ret = gst_pad_link (pad, sinkpad)) != GST_PAD_LINK_OK) {
    msg = g_strdup_printf ("Can not link pads (%d)", ret);
    gst_object_unref (sinkpad);
    goto failed;
  }

  gst_object_unref (sinkpad);

  if (!gst_element_link (wavenc, sink)) {
    msg = g_strdup_printf ("Can not link elements");
    goto failed;
  }

  gst_element_sync_state_with_parent (wavenc);
  gst_element_sync_state_with_parent (sink);

  return;

failed:

  gst_element_set_state (wavenc, GST_STATE_NULL);
  gst_element_set_state (sink, GST_STATE_NULL);
  gst_bin_remove_many (GST_BIN (pipeline), wavenc, sink, NULL);

  GST_ERROR ("Error %s", msg);
  fail (msg);
  g_free (msg);
}

GST_START_TEST (check_audio_connection)
{
  GstElement *pipeline, *audiotestsrc1, *audiotestsrc2, *audiotestsrc3,
      *audiomixer;
  guint bus_watch_id;
  GstBus *bus;

  GMainLoop *loop = g_main_loop_new (NULL, FALSE);

  /* Create gstreamer elements */
  pipeline = gst_pipeline_new ("audimixer0-test");
  audiotestsrc1 = gst_element_factory_make ("audiotestsrc", NULL);
  audiotestsrc2 = gst_element_factory_make ("audiotestsrc", NULL);
  audiotestsrc3 = gst_element_factory_make ("audiotestsrc", NULL);
  audiomixer = gst_element_factory_make ("audiomixer", NULL);

  g_object_set (G_OBJECT (audiotestsrc1), "wave", 0, NULL);
  g_object_set (G_OBJECT (audiotestsrc2), "wave", 8, NULL);
  g_object_set (G_OBJECT (audiotestsrc3), "wave", 11, NULL);

  g_signal_connect (audiomixer, "pad-added", G_CALLBACK (cb_new_pad), pipeline);

  bus = gst_pipeline_get_bus (GST_PIPELINE (pipeline));

  bus_watch_id = gst_bus_add_watch (bus, gst_bus_async_signal_func, NULL);
  g_signal_connect (bus, "message", G_CALLBACK (bus_msg), pipeline);
  g_object_unref (bus);

  gst_bin_add_many (GST_BIN (pipeline), audiotestsrc1, audiotestsrc2,
      audiotestsrc3, audiomixer, NULL);
  gst_element_link (audiotestsrc1, audiomixer);
  gst_element_link (audiotestsrc2, audiomixer);
  gst_element_link (audiotestsrc3, audiomixer);

  g_timeout_add (3000, quit_main_loop, loop);

  GST_DEBUG_BIN_TO_DOT_FILE_WITH_TS (GST_BIN (pipeline),
      GST_DEBUG_GRAPH_SHOW_ALL, "entering_main_loop");

  gst_element_set_state (pipeline, GST_STATE_PLAYING);

  GST_DEBUG ("Test running");

  g_main_loop_run (loop);

  GST_DEBUG ("Stop executed");

  GST_DEBUG_BIN_TO_DOT_FILE_WITH_TS (GST_BIN (pipeline),
      GST_DEBUG_GRAPH_SHOW_ALL, "after_main_loop");

  gst_element_set_state (pipeline, GST_STATE_NULL);
  gst_object_unref (GST_OBJECT (pipeline));
  GST_DEBUG ("Pipe released");

  g_source_remove (bus_watch_id);
  g_main_loop_unref (loop);
}

GST_END_TEST
/******************************/
/* audiomixer test suit */
/******************************/
static Suite *
audiomixer_suite (void)
{
  Suite *s = suite_create ("audiomixer");
  TCase *tc_chain = tcase_create ("element");

  suite_add_tcase (s, tc_chain);
  tcase_add_test (tc_chain, check_audio_connection);

  return s;
}

GST_CHECK_MAIN (audiomixer);
